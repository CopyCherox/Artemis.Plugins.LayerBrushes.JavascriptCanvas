{
  "ScriptName": "Test Script",
  "JavaScriptCode": "/**\r\n * ARTEMIS JAVASCRIPT API TEST SUITE\r\n * Verifies all functions defined in the provided C# CanvasContext\r\n */\r\n\r\n// 1. STATE INITIALIZATION (Testing Persistent State)\r\nif (state.initialized === undefined) {\r\n    state.initialized = true;\r\n    state.counter = 0;\r\n    console.log(\u0022Test Suite Initialized\u0022);\r\n}\r\nstate.counter \u002B= 1; // Increment every frame\r\n\r\n// 2. SETUP GRID SYSTEM\r\n// We divide the screen into a 4x4 grid to test features in isolation\r\nlet cols = 4;\r\nlet rows = 4;\r\nlet w = width / cols;\r\nlet h = height / rows;\r\n\r\n// Clear background (Dark Grey)\r\nctx.clear(30, 30, 30);\r\n\r\n// Helper to reset transform and move to specific cell\r\nfunction setupCell(col, row, title) {\r\n    ctx.restore(); // Restore to clean state\r\n    ctx.save();    // Save clean state\r\n    \r\n    // Translate to cell position\r\n    let x = col * w;\r\n    let y = row * h;\r\n    ctx.translate(x, y);\r\n    \r\n    // Draw Cell Border\r\n    ctx.strokeStyle(60, 60, 60, 255);\r\n    ctx.lineWidth(1);\r\n    ctx.strokeRect(0, 0, w, h);\r\n    \r\n    // Clip to cell (Testing ctx.clip and ctx.rect)\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, w, h);\r\n    ctx.clip();\r\n    \r\n    // Draw Title (Testing Text)\r\n    ctx.fillStyle(200, 200, 200, 255);\r\n    ctx.setFont(\u002210px Arial\u0022);\r\n    ctx.textAlign(\u0022start\u0022);\r\n    ctx.textBaseline(\u0022top\u0022);\r\n    ctx.fillText(title, 5, 5);\r\n    \r\n    // Move \u0022cursor\u0022 to center of cell for drawing\r\n    ctx.translate(w/2, h/2);\r\n}\r\n\r\n// Start fresh\r\nctx.save(); \r\n\r\n// =========================================================\r\n// ROW 1: BASIC SHAPES \u0026 DRAWING\r\n// =========================================================\r\n\r\n// [0,0] Basic Rects \u0026 Clearing\r\nsetupCell(0, 0, \u0022Rects \u0026 Clear\u0022);\r\nctx.fillStyle(255, 100, 100, 255); \r\nctx.fillRect(-20, -20, 40, 40);      // Red Box\r\nctx.clearRect(-10, -10, 20, 20);     // Clear Hole\r\nctx.strokeStyle(255, 255, 255, 255);\r\nctx.strokeRect(-25, -25, 50, 50);    // White Outline\r\n\r\n// [1,0] Circles \u0026 Lines\r\nsetupCell(1, 0, \u0022Circles \u0026 Lines\u0022);\r\nctx.fillStyle(100, 255, 100, 255);\r\nctx.fillCircle(-15, 0, 15);          // Green Circle\r\nctx.strokeStyle(255, 255, 0, 255);\r\nctx.lineWidth(3);\r\nctx.strokeCircle(15, 0, 15);         // Yellow Ring\r\nctx.lineWidth(2);\r\nctx.strokeStyle(255, 255, 255, 150);\r\nctx.drawLine(-w/2, -h/2, w/2, h/2);  // Diagonal Line\r\n\r\n// [2,0] Paths \u0026 Curves\r\nsetupCell(2, 0, \u0022Paths \u0026 Curves\u0022);\r\nctx.beginPath();\r\nctx.moveTo(-20, 20);\r\nctx.quadraticCurveTo(0, -20, 20, 20); // Curve\r\nctx.lineTo(0, 30);\r\nctx.closePath();\r\nctx.fillStyle(100, 100, 255, 255);\r\nctx.fill();\r\nctx.strokeStyle(255, 255, 255, 255);\r\nctx.stroke();\r\n\r\n// [3,0] Complex Paths (Arc/Bezier)\r\nsetupCell(3, 0, \u0022Arc \u0026 Bezier\u0022);\r\nctx.beginPath();\r\nctx.arc(0, 0, 15, 0, Math.PI, false); // Half circle\r\nctx.bezierCurveTo(-30, 30, 30, 30, 0, 0); // Bezier bottom\r\nctx.fillStyle(255, 0, 255, 255);\r\nctx.fill();\r\n\r\n// =========================================================\r\n// ROW 2: STYLES \u0026 GRADIENTS\r\n// =========================================================\r\n\r\n// [0,1] Linear Gradient\r\nsetupCell(0, 1, \u0022Linear Gradient\u0022);\r\n// API: createLinearGradient(x0, y0, x1, y1)\r\nlet lGrad = ctx.createLinearGradient(-20, -20, 20, 20);\r\n// API: addColorStop(offset, r, g, b, a)\r\nlGrad.addColorStop(0, 255, 0, 0, 255);   // Red\r\nlGrad.addColorStop(1, 0, 0, 255, 255);   // Blue\r\nctx.fillStyleGradient(lGrad);\r\nctx.fillRect(-20, -20, 40, 40);\r\n\r\n// [1,1] Radial Gradient\r\nsetupCell(1, 1, \u0022Radial Gradient\u0022);\r\n// API: createRadialGradient(x0, y0, r0, x1, y1, r1)\r\nlet rGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);\r\nrGrad.addColorStop(0, 255, 255, 0, 255); // Yellow center\r\nrGrad.addColorStop(1, 0, 0, 0, 255);     // Black edge\r\nctx.fillStyleGradient(rGrad);\r\nctx.fillCircle(0, 0, 25);\r\n\r\n// [2,1] Shadows \u0026 Line Styles\r\nsetupCell(2, 1, \u0022Shadows \u0026 Caps\u0022);\r\nctx.shadowColor(0, 255, 255, 255); // Cyan Glow\r\nctx.shadowBlur(10);\r\nctx.shadowOffsetX(5);\r\nctx.shadowOffsetY(5);\r\nctx.lineWidth(8);\r\nctx.lineCap(\u0022round\u0022);\r\nctx.strokeStyle(255, 255, 255, 255);\r\nctx.beginPath();\r\nctx.moveTo(-20, 0);\r\nctx.lineTo(20, 0);\r\nctx.stroke();\r\n// Reset shadows for next cells\r\nctx.shadowBlur(0);\r\n\r\n// [3,1] HSL Helper\r\nsetupCell(3, 1, \u0022HSL to RGB\u0022);\r\n// Cycling rainbow using time and HSL helper\r\nlet hVal = (time * 0.5) % 1.0;\r\nlet rgb = ctx.hslToRgb(hVal, 1.0, 0.5);\r\nctx.fillStyle(rgb.r, rgb.g, rgb.b, 255);\r\nctx.fillCircle(0, 0, 20);\r\n// Verify RGB to HSL\r\nlet backToHsl = ctx.rgbToHsl(rgb.r, rgb.g, rgb.b);\r\nctx.fillStyle(255, 255, 255, 255);\r\nctx.fillText(\u0022H:\u0022 \u002B backToHsl.h.toFixed(2), -20, 20);\r\n\r\n// =========================================================\r\n// ROW 3: TRANSFORMS \u0026 TEXT\r\n// =========================================================\r\n\r\n// [0,2] Rotation \u0026 Scale\r\nsetupCell(0, 2, \u0022Rotate \u0026 Scale\u0022);\r\nctx.save();\r\nctx.rotate(time); // Rotate continuously\r\nctx.scale(0.5 \u002B Math.sin(time)*0.2, 0.5 \u002B Math.sin(time)*0.2); // Pulse\r\nctx.fillStyle(255, 128, 0, 255);\r\nctx.fillRect(-20, -20, 40, 40);\r\nctx.restore();\r\n\r\n// [1,2] Text Alignment\r\nsetupCell(1, 2, \u0022Text Align\u0022);\r\nctx.setFont(\u002212px Arial\u0022);\r\nctx.fillStyle(255, 255, 255, 255);\r\n\r\nctx.textAlign(\u0022center\u0022);\r\nctx.fillText(\u0022Center\u0022, 0, -10);\r\n\r\nctx.textAlign(\u0022right\u0022);\r\nctx.fillStyle(255, 100, 100, 255);\r\nctx.fillText(\u0022Right\u0022, 0, 5);\r\n\r\nctx.textAlign(\u0022left\u0022);\r\nctx.fillStyle(100, 255, 100, 255);\r\nctx.fillText(\u0022Left\u0022, 0, 20);\r\n\r\n// [2,2] Measure Text\r\nsetupCell(2, 2, \u0022Measure Text\u0022);\r\nlet txt = \u0022Width?\u0022;\r\nlet m = ctx.measureText(txt);\r\n// Draw box exactly size of text\r\nctx.fillStyle(50, 50, 50, 255);\r\nctx.fillRect(-m.width/2, -10, m.width, 20);\r\nctx.fillStyle(255, 255, 255, 255);\r\nctx.textAlign(\u0022center\u0022);\r\nctx.textBaseline(\u0022middle\u0022);\r\nctx.fillText(txt, 0, 0);\r\n\r\n// [3,2] Alpha \u0026 Composition\r\nsetupCell(3, 2, \u0022Alpha\u0022);\r\nctx.globalAlpha(0.5);\r\nctx.fillStyle(255, 0, 0, 255);\r\nctx.fillCircle(-10, -5, 15);\r\nctx.fillStyle(0, 0, 255, 255);\r\nctx.fillCircle(10, 5, 15);\r\nctx.globalAlpha(1.0); // Reset\r\n\r\n// =========================================================\r\n// ROW 4: INTERACTIVITY \u0026 AUDIO\r\n// =========================================================\r\n\r\n// [0,3] State Persistence\r\nsetupCell(0, 3, \u0022State \u0026 Time\u0022);\r\nctx.textAlign(\u0022center\u0022);\r\nctx.fillStyle(255, 255, 255, 255);\r\nctx.fillText(\u0022Count: \u0022 \u002B state.counter, 0, -5);\r\nctx.fillText(\u0022Time: \u0022 \u002B time.toFixed(1), 0, 10);\r\n\r\n// [1,3] Audio Bass\r\nsetupCell(1, 3, \u0022Audio Bass\u0022);\r\nif (audio.IsEnabled) {\r\n    let barH = audio.Bass * 40;\r\n    ctx.fillStyle(0, 255, 0, 255);\r\n    ctx.fillRect(-10, 20, 20, -barH);\r\n} else {\r\n    ctx.fillText(\u0022No Audio\u0022, 0, 0);\r\n}\r\n\r\n// [2,3] Audio Spectrum (GetBand)\r\nsetupCell(2, 3, \u0022Spectrum\u0022);\r\nif (audio.IsEnabled) {\r\n    ctx.fillStyle(0, 200, 255, 255);\r\n    let barW = (w - 10) / 5;\r\n    for(let i=0; i\u003C5; i\u002B\u002B) {\r\n        // Sample bands 0, 2, 4, 6, 8\r\n        let amp = audio.GetBand(i*2) * 30; \r\n        ctx.fillRect(-w/2 \u002B 5 \u002B (i*barW), 20, barW-2, -amp);\r\n    }\r\n}\r\n\r\n// [3,3] Hit Detection (isPointInPath)\r\nsetupCell(3, 3, \u0022Hit Test\u0022);\r\nctx.beginPath();\r\nctx.rect(-15, -15, 30, 30);\r\n// We fake a \u0022mouse\u0022 point moving in circles\r\nlet mx = Math.sin(time * 2) * 20;\r\nlet my = Math.cos(time * 2) * 20;\r\n\r\n// Draw the target\r\nctx.strokeStyle(255, 255, 255, 255);\r\nctx.stroke();\r\n\r\n// Check if our point is inside the rect\r\n// Note: In this specific API, isPointInPath uses local coordinates relative to the path\r\nif (ctx.isPointInPath(mx, my)) {\r\n    ctx.fillStyle(0, 255, 0, 255); // Green if hit\r\n} else {\r\n    ctx.fillStyle(255, 0, 0, 255); // Red if miss\r\n}\r\n\r\n// Draw the \u0022mouse\u0022 point\r\nctx.fillCircle(mx, my, 3);\r\n\r\n// Final cleanup\r\nctx.restore();"
}