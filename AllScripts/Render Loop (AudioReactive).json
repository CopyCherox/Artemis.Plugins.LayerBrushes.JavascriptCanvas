{
  "ScriptName": "Render Loop (AudioReactive)",
  "JavaScriptCode": "// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n// \u2728 CONFIGURATION\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nconst config = {\n  cols: 12,             // Horizontal grid detail\n  rows: 8,              // Vertical grid detail\n  sway: 30,             // How much points move\n  speed: 1.5,           // Movement speed\n  baseColor: 200        // Base Hue (Blue/Cyan)\n};\n\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n// \uD83C\uDFA8 RENDER LOOP\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n// We need to calculate points slightly outside the screen \n// to ensure no black edges appear when they sway inward.\nconst xStep = width / config.cols;\nconst yStep = height / config.rows;\nconst t = time * config.speed;\n\n// Audio affects the color brightness\nlet energy = audio.IsEnabled ? (audio.Bass * 0.4) : 0;\n\n// Helper to get a wandering point based on grid index\nfunction getPoint(ix, iy) {\n    // Pseudo-random deterministic noise based on coordinates\n    let noiseX = Math.sin(ix * 0.5 \u002B t) \u002B Math.cos(iy * 0.5 \u002B t);\n    let noiseY = Math.cos(ix * 0.3 \u002B t) \u002B Math.sin(iy * 0.8 \u002B t);\n    \n    return {\n        x: (ix * xStep) \u002B (noiseX * config.sway),\n        y: (iy * yStep) \u002B (noiseY * config.sway)\n    };\n}\n\n// We draw grid cells as two triangles forming a quad\n// To cover edges, we loop from -1 to cols\u002B1\nfor (let y = -1; y \u003C= config.rows; y\u002B\u002B) {\n    for (let x = -1; x \u003C= config.cols; x\u002B\u002B) {\n        \n        // Get the 4 corners of this grid cell\n        let p1 = getPoint(x, y);         // Top-Left\n        let p2 = getPoint(x\u002B1, y);       // Top-Right\n        let p3 = getPoint(x, y\u002B1);       // Bottom-Left\n        let p4 = getPoint(x\u002B1, y\u002B1);     // Bottom-Right\n        \n        // \uD83D\uDD3C Triangle 1 (Top-Left, Top-Right, Bottom-Left)\n        // Color based on angle/noise\n        let h1 = (config.baseColor \u002B (x*10) \u002B (y*5)) % 360;\n        let l1 = 0.3 \u002B ((Math.sin(x \u002B t) \u002B 1) * 0.2) \u002B energy;\n        let rgb1 = ctx.hslToRgb(h1/360, 1.0, l1);\n        \n        ctx.fillStyle(rgb1.r, rgb1.g, rgb1.b, 255);\n        ctx.strokeStyle(rgb1.r, rgb1.g, rgb1.b, 255); // Stroke seals gaps\n        ctx.lineWidth(1);\n        \n        ctx.beginPath();\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(p2.x, p2.y);\n        ctx.lineTo(p3.x, p3.y);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // \uD83D\uDD3D Triangle 2 (Top-Right, Bottom-Right, Bottom-Left)\n        // Slightly different lighting\n        let l2 = 0.2 \u002B ((Math.cos(y \u002B t) \u002B 1) * 0.2) \u002B energy;\n        let rgb2 = ctx.hslToRgb(h1/360, 1.0, l2);\n        \n        ctx.fillStyle(rgb2.r, rgb2.g, rgb2.b, 255);\n        ctx.strokeStyle(rgb2.r, rgb2.g, rgb2.b, 255);\n        \n        ctx.beginPath();\n        ctx.moveTo(p2.x, p2.y);\n        ctx.lineTo(p4.x, p4.y);\n        ctx.lineTo(p3.x, p3.y);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n    }\n}"
}