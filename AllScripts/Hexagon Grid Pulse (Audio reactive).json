{
  "ScriptName": "Hexagon Grid Pulse (Audio Reactive)",
  "JavaScriptCode": "// ============================================\n// CONFIGURATION\n// ============================================\nlet CONFIG = {\n    hexSize: 40,               // Hexagon size (15-80) - SAFE RANGE\n    bassGrow: 1.2,             // Bass size impact (1.0-3.0)\n    colorSpeed: 0.1,\n    glowAmount: 0.1,\n    pattern: \u0022honeycomb\u0022       // \u0022honeycomb\u0022, \u0022offset\u0022, \u0022wave\u0022\n};\n\n// ============================================\n// SAFETY LIMITS\n// ============================================\nCONFIG.hexSize = Math.max(15, Math.min(80, CONFIG.hexSize)); // Clamp to safe range\nconst MAX_HEXAGONS = 1000; // Hard limit to prevent crashes\n\n// ============================================\n// MAIN EFFECT\n// ============================================\n\nlet bass = audio.IsEnabled ? audio.Bass : Math.abs(Math.sin(time * 2)) * 0.7;\nlet mid = audio.IsEnabled ? audio.Midrange : Math.abs(Math.sin(time * 2.5)) * 0.6;\nlet treble = audio.IsEnabled ? audio.Treble : Math.abs(Math.sin(time * 3)) * 0.5;\n\n// Vibrant background\nlet bgHue = (time * CONFIG.colorSpeed) % 1.0;\nlet bgRgb = ctx.hslToRgb(bgHue, 0.7, 0.3);\nctx.clear(bgRgb.r, bgRgb.g, bgRgb.b);\n\nlet hexWidth = CONFIG.hexSize * 2;\nlet hexHeight = CONFIG.hexSize * 1.732; // sqrt(3)\nlet cols = Math.ceil(width / hexWidth) \u002B 2;\nlet rows = Math.ceil(height / hexHeight) \u002B 2;\n\n// Safety check: limit total hexagons\nlet totalHexagons = cols * rows;\nif (totalHexagons \u003E MAX_HEXAGONS) {\n    // Scale down to fit within limit\n    let scale = Math.sqrt(MAX_HEXAGONS / totalHexagons);\n    cols = Math.floor(cols * scale);\n    rows = Math.floor(rows * scale);\n}\n\nlet hexagonCount = 0;\n\nfor (let row = -1; row \u003C rows; row\u002B\u002B) {\n    for (let col = -1; col \u003C cols; col\u002B\u002B) {\n        // Hard stop if we exceed limit\n        if (hexagonCount \u003E= MAX_HEXAGONS) break;\n        hexagonCount\u002B\u002B;\n        \n        let x = col * hexWidth * 0.75;\n        let y = row * hexHeight;\n        \n        // Offset every other row\n        if (row % 2 === 1) {\n            x \u002B= hexWidth * 0.375;\n        }\n        \n        // Distance from center for radial effects\n        let dx = x - width / 2;\n        let dy = y - height / 2;\n        let dist = Math.sqrt(dx * dx \u002B dy * dy);\n        let distNorm = dist / Math.max(width, height);\n        \n        // Audio response based on position\n        let audioValue;\n        if (distNorm \u003C 0.3) {\n            audioValue = bass;\n        } else if (distNorm \u003C 0.6) {\n            audioValue = mid;\n        } else {\n            audioValue = treble;\n        }\n        \n        // Wave pattern\n        let wave = Math.sin(dist * 0.03 - time * 3);\n        \n        // Size calculation\n        let size = CONFIG.hexSize * (0.8 \u002B audioValue * CONFIG.bassGrow * 0.5 \u002B Math.abs(wave) * 0.3);\n        \n        // Color\n        let hue = (distNorm * 0.5 \u002B time * CONFIG.colorSpeed \u002B audioValue * 0.3) % 1.0;\n        let lightness = 0.4 \u002B audioValue * 0.4;\n        let rgb = ctx.hslToRgb(hue, 0.95, lightness);\n        \n        // Glow (only for high audio)\n        if (audioValue \u003E 0.5) {\n            ctx.fillStyle(rgb.r, rgb.g, rgb.b, CONFIG.glowAmount);\n            drawHexagon(x, y, size * 1.3);\n        }\n        \n        // Main hexagon\n        ctx.fillStyle(rgb.r, rgb.g, rgb.b);\n        drawHexagon(x, y, size);\n    }\n    if (hexagonCount \u003E= MAX_HEXAGONS) break;\n}\n\nfunction drawHexagon(cx, cy, size) {\n    ctx.beginPath();\n    for (let i = 0; i \u003C 6; i\u002B\u002B) {\n        let angle = (Math.PI / 3) * i;\n        let px = cx \u002B size * Math.cos(angle);\n        let py = cy \u002B size * Math.sin(angle);\n        if (i === 0) ctx.moveTo(px, py);\n        else ctx.lineTo(px, py);\n    }\n    ctx.closePath();\n    ctx.fill();\n}\n"
}