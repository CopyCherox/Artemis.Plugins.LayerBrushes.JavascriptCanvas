{
  "ScriptName": "Liquid Plasma",
  "JavaScriptCode": "// ==================== CONFIG ====================\nconst config = {\n    resolution: 15, // Size of each \u0022pixel\u0022 block (Lower = higher quality but slower)\n    zoom: 0.02,     // How tight the waves are\n    speed: 1.5      // Animation speed\n};\n\n// ==================== DRAW ====================\n// No clear needed, we overwrite everything\n\nlet cols = Math.ceil(width / config.resolution);\nlet rows = Math.ceil(height / config.resolution);\nlet t = time * config.speed;\n\n// Audio modulates the \u0022zoom\u0022 or frequency slightly\nlet warp = audio.IsEnabled ? (audio.Bass * 0.5) : 0;\n\nfor (let y = 0; y \u003C rows; y\u002B\u002B) {\n    for (let x = 0; x \u003C cols; x\u002B\u002B) {\n        // Calculate coordinate in \u0022plasma space\u0022\n        let px = x * config.resolution;\n        let py = y * config.resolution;\n        \n        // Sum of sines creates the \u0022liquid\u0022 look\n        // Wave 1: Diagonal movement\n        let v1 = Math.sin(px * config.zoom \u002B t);\n        // Wave 2: Circular movement\n        let v2 = Math.sin((py * config.zoom) \u002B t * 0.5);\n        // Wave 3: Complex interference\n        let v3 = Math.sin(((px \u002B py) * config.zoom * 0.5) \u002B t);\n        // Wave 4: Audio distortion\n        let v4 = Math.sin(Math.sqrt(px*px \u002B py*py) * 0.01 \u002B warp);\n\n        // Average them to get -1 to 1, then map to 0-1\n        let avg = (v1 \u002B v2 \u002B v3 \u002B v4) / 4; \n        \n        // Map to color (Rainbow palette)\n        // We shift hue based on the value \u0027avg\u0027\n        let hue = (avg \u002B 1) * 0.5; // Map -1..1 to 0..1\n        \n        // Convert to RGB\n        let rgb = ctx.hslToRgb(hue, 1.0, 0.5);\n        \n        ctx.fillStyle(rgb.r, rgb.g, rgb.b, 255);\n        \n        // Draw the block (slightly overlapping to prevent grid lines)\n        ctx.fillRect(px, py, config.resolution \u002B 1, config.resolution \u002B 1);\n    }\n}"
}